from telegram.ext import Updater, CommandHandler, MessageHandler, Filters, CallbackContext

TOKEN = "6930205247:AAGUvM-Xv5eN3AGld67LQ8CoeZvynWIPsbM"

questions_and_answers = {
    1: ("Что такое LA? В каких единицах измеряется?", "LA означает загрузку системы . Это число, показывающее, насколько сильно загружен процессор. Измеряется в трех интервалах времени: за последнюю минуту, за последние 5 и 15. Чем выше число, тем больше загрузка на процессоре. Например, значение 100 означает, что процессор полностью загружен"),
    2: ("Что будет если на сервере LA = 100?", "Это указывает на высокую перегрузку. Возможны замедление работы, отказ в обслуживании, система может стать неотзывчивой. Требуется вмешательство для снижения нагрузки или увеличения ресурсов."),
    3: ("Почему при высоких показателях значения LA на сервере может не наблюдаться проблем (консоль ssh отзывается, сервисы работают в обычном режиме)?", "Высокие значения загрузки системы могут быть не проблемой, если система эффективно управляет ресурсами, имеет резервные мощности, и приложения могут адекватно обрабатывать высокую нагрузку, имеет  краткосрочные пики и оптимизированные сервисыВысокие значения загрузки системы могут быть не проблемой, если система эффективно управляет ресурсами, имеет резервные мощности, и приложения могут адекватно обрабатывать высокую нагрузку, имеет  краткосрочные пики и оптимизированные сервисы"),
    4: ("Представлен вывод команды top. Что означает каждая запись в выводе? top - 21:29:24 up 14:18, 1 user, load average: 0,78, 1,48, 1,10 Tasks: 277 total, 3 running, 274 sleeping, 0 stopped, 0 zombie %Cpu(s): 12,4 us, 2,5 sy, 0,1 ni, 84,8 id, 0,1 wa, 0,0 hi, 0,1 si, 0,0 st KiB Mem : 7106404 total, 306972 free, 3127144 used, 3672288 buff/cache KiB Swap: 8191996 total, 8191996 free, 0 used. 3270520 avail Mem", "Верхняя строка:21:29:24 - текущее время.up 14:18 - система работает 14 часов и 18 минут.1 user - 1 пользователь в настоящее время подключен.load average: 0,78, 1,48, 1,10 - значения загрузки системы за последние 1, 5 и 15 минут соответственно. Значение load average показывает, насколько система загружена. В данном случае, она не слишком перегружена.Строка задач:277 total - всего задач.3 running - 3 задачи выполняются в данный момент.274 sleeping - 274 задачи ожидают выполнения.0 stopped - 0 задач приостановлено.0 zombie - 0 зомби-процессов.Строка CPU:%Cpu(s): - процент использования CPU.12,4 us - процент времени CPU, используемый пользовательскими процессами.2,5 sy - процент времени CPU, используемый системными процессами.0,1 ni - процент времени CPU, используемый процессами с измененным приоритетом (nice).84,8 id - процент времени CPU в режиме ожидания (idle).0,1 wa - процент времени CPU в режиме ожидания ввода/вывода.0,0 hi - процент времени CPU в режиме обработки аппаратных прерываний.0,1 si - процент времени CPU в режиме обработки программных прерываний.0,0 st - процент времени CPU, украденный виртуализацией для других виртуальных машин.Строка памяти (KiB Mem и KiB Swap):7106404 total - общий объем оперативной памяти.306972 free - свободно оперативной памяти.3127144 used - используемо оперативной памяти.3672288 buff/cache - объем памяти, используемый для буферов и кэша.Далее идет информация о памяти на разделе Swap (память подкачки)."),
    5: ("Как в утилите top в Linux посмотреть нагрузку на каждое ядро процессора?", "Находясь внутри top, нажмите клавишу 1. Это переключит режим отображения, где каждое ядро процессора будет представлено отдельным графиком и статистикой. Далее вы увидите, как загрузка CPU будет разбита на каждое ядро, а также на общую загрузку системы. Для выхода нажмите клавишу 1 еще раз."),
    6: ("Как в утилите top в Linux посмотреть какой командой был запущен процесс?", "Находясь внутри top, нажмите клавишу с. Это переключит отображение командных строк для каждого процесса в списке. Это покажет полные команды, с помощью которых были запущены процессы."),
    7: ("Где хранятся имена файлов/директорий?", "В инодах, которые содержат метаданные файлов, их имена, права доступа. Каталоги - специальные файлы, связывающие  имена с инодами."),
    8: ("Как удалить файл с именем -rf?", "Нельзя удалить его с использованием команды rm -rf, т.к эта команда интерпретирует аргумент -rf как опцию для рекурсивного удаления, что может привести к удалению всех файлов и каталогов в текущем рабочем каталоге.  Нужна команда rm ./-rf"),
    9: ("Как посмотреть описание дескриптора? Как посмотреть время последней модификации файла?", "Описание дескриптора - stat файл. Время последней модификации файла - stat -c '%y' файл. Для даты - stat -c '%y' файл | cut -d' ' -f1. Для времени - stat -c '%y' файл | cut -d' ' -f2"),
    10: ("Для чего нужна переменная окружения PATH?", "Переменная окружения PATH содержит список директорий, в которых операционная система ищет исполняемые файлы при вводе команд в командной строке. Она обеспечивает удобство, позволяя использовать команды без указания полного пути к исполняемым файлам"),
    11: ("Как посмотреть нагрузку на диски?", "iostat - Статистика использования дисков в реальном времени. iotop - Мониторинг использования дисков по процессам. df - Общий объем свободного места на диске. du - Размер конкретных директорий"),
    12: ("Что такое файл в понятиях Unix-like операционных системах?", "Файл - это абстракция для хранения данных. Он имеет имя, тип (исполняемый, текстовый, директория и др.), размер, временные метки (доступа, модификации, изменения), права доступа, расположение в файловой системе, владельца и группу. Концепция все является файлом является ключевой чертой дизайна Unix."),
    13: ("Что такое RAID? Какие массивы бывают?", "RAID в Linux объединяет диски для улучшения производительности или отказоустойчивости. Типы RAID: RAID 0: Увеличивает производительность, но не обеспечивает отказоустойчивость. RAID 1: Обеспечивает отказоустойчивость за счет зеркалирования данных. RAID 5: Комбинирует производительность и отказоустойчивость. RAID 6: Предоставляет дополнительную отказоустойчивость. RAID 10: Комбинирует зеркалирование и стрипинг для производительности и отказоустойчивости."),
    14: ("При каком количестве одновременно вышедших из строя дисков обеспечивает работоспособность RAID 6?", "Обеспечивает работоспособность при выходе из строя до двух дисков одновременно. Этот уровень RAID использует два блока четности, что позволяет ему обнаруживать и восстанавливать данные после отказа любых двух дисков. Таким образом, даже если два диска выйдут из строя, данные сохраняются и система остается работоспособной."),
    15: ("В чем разница между объявлением переменной export VAR=value и VAR=VALUE в bash?", "Пи использовании  export перед объявлением переменной в Bash (export VAR='VALUE'), переменная становится переменной окружения и передается подпроцессам. Без export (VAR='VALUE'), переменная ограничивается текущим сеансом Bash и не передается подпроцессам."),
    16: ("Как остановить выполнение скрипта в bash при возникновении ошибки в команде?", "Чтобы остановить выполнение скрипта в bash при возникновении ошибки, добавьте set -e в начало скрипта. Это приведет к завершению скрипта при ошибке в любой команде с ненулевым статусом выхода."),
    17: ("Что в bash скрипте означает команда set -euo pipefail?", "Устанавливает опции: -e  Останавливает скрипт при ошибке. -u Завершает скрипт при использовании неопределенной переменной. -o pipefail Завершает скрипт при ошибке в любой команде конвейера (pipe)."),
    18: ("Как активировать debug режим в bash?", "Для активации set -x. Для отключения set +x"),
    19: ("Что значит $@ в bash?", "$@ в bash представляет собой переменную, содержащую все аргументы командной строки, переданные скрипту или функции"),
    20: ("Какой код сигнала будет выполнен при исполнении команды kill?", "Команда kill в Linux, при использовании без указания конкретного сигнала, отправляет сигнал TERM (15) процессу. Например, kill PID эквивалентно kill -s TERM PID. Сигнал TERM обычно используется для запроса завершения процесса."),
    21: ("Как выполнить фильтрацию вывода команды, чтобы на экран были выведены только ошибки (STDERR), игнорируя STDOUT?", "command 2>&1 >/dev/null"),
    22: ("Какую команду необходимо выполнить, чтобы посмотреть какие пользователи вошли в систему в систему?", "who - Эта команда отобразит список пользователей, вошедших в систему, с указанием их имен, терминалов, с которых они вошли, даты и времени входа"),
    23: ("Какой файл необходимо отредактировать, чтобы отключить ssh аутентификацию по паролю?", "Для отключения SSH аутентификации по паролю отредактируйте файл /etc/ssh/sshd_config, измените PasswordAuthentication на no, и перезапустите службу SSH."),
    24: ("В каком файле находится информация о смонтированных каталогах в файловую систему?", "Информация о смонтированных каталогах в файловую систему содержится в файле /proc/mounts."),
    25: ("Что выведет команда cat a и почему? mkdir /tmp/abc cd /tmp/abc ls >a 2>b cat a", "Команда cat a выведет содержимое файла a, который был создан выводом команды ls. Файл b будет пустым или содержать ошибки (если они возникнут) из команды ls 2>b."),
    26: ("В bash-скрипте указан атрибут оболочки set -x. В одной из команд происходит ошибка и скрипт завершает свою работу. Как сделать, чтобы при возникновении ошибки в определенной команде скрипт продолжил свою работу?", "command1 || true"),
    27: ("Что такое системный вызов, какие они бывают?", "Системный вызов (System Call) - это интерфейс, предоставляемый операционной системой для выполнения привилегированных операций прикладными программами. Он включает в себя функции для управления процессами, файлами, памятью, устройствами, синхронизацией процессов и сетевыми операциями. Примеры включают fork(), open(), read(), write(), и другие."),
    28: ("Что такое сигнал в Unix, зачем они нужны и разница между 9 и 15 сигналами?", "Сигналы в Unix - механизм асинхронного уведомления о событиях в процессах. Сигнал 9 (SIGKILL) принудительно завершает процесс без возможности обработки, в то время как сигнал 15 (SIGTERM) предоставляет процессу возможность корректного завершения с выполнением завершающих операций."),
    29: ("Что такое inode? Какая информация там хранится?", "Inode (Index Node) - это структура данных в Unix-подобных файловых системах, содержащая метаданные о файле или каталоге. Она включает информацию, такую как идентификатор файла, размер, права доступа, владелец, временные метки, количество жестких ссылок и адреса блоков данных. Inode ассоциирован с каждым файлом и служит для его уникальной идентификации в файловой системе."),
    30: ("Что такое hard link? В чем разница между hard link и soft link? Примеры их практического применения.", "Жесткая ссылка: указывает на тот же inode, не может ссылаться на каталоги, находится в пределах одной файловой системы. Символическая ссылка: содержит путь к целевому файлу, может ссылаться на несуществующие объекты, пожет пересекать границы файловых систем. Примеры: Жесткая ссылка: множество имен для одного исполняемого файла, журналирование с несколькими именами для одного файла, Символическая ссылка: создание псевдонимов для файлов, указание на разделяемые ресурсы в различных местах."),
    31: ("Какие состояния процессов существуют? Что значит состояние процесса D?", "Running (R) - Выполняется. Waiting (Sleeping) - Ожидает события. Stopped (T) - Приостановлен. Zombie (Z) - Завершил выполнение, ожидает освобождения ресурсов.Dead (D) - Блокирован вводом/выводом, неотвечает на сигналы."),
    32: ("Что такое процесс-зомби и процесс-сирота? Можно ли самостоятельно сделать зомби?", "Процесс-зомби - Завершил выполнение, но запись о завершении не удалена. Исчезнет после обработки родителем информации о завершении.Процесс-сирота - Дочерний процесс, который ожидает завершения родительского.Родитель завершил выполнение, система присваивает нового родителя. Создание зомби - Нельзя создать зомби намеренно.Зомби возникает, если родительский процесс не обрабатывает завершение дочернего.Создание сироты - Может возникнуть, если родитель завершится раньше дочернего.Система присваивает нового родителя."),
    33: ("Что такое файловый дескриптор? Какая информация там хранится?", "Файловый дескриптор - целочисленное значение, идентифицирующее открытый файл или поток данных в Unix-подобных системах. Включает текущую позицию чтения/записи, флаги доступа, режим открытия файла и ссылки на таблицу файлов системы для отслеживания открытых файлов. Обеспечивает универсальный интерфейс для работы с файлами и устройствами в операционной системе."),
    34: ("Что такое buffer/cache память? Для чего нужна?", "Буферная память: Временное хранение данных между медленными устройствами. Кэш-память: Хранение копий данных для ускорения доступа к ним. Улучшают производительность и сглаживают разницу в скоростях доступа."),
    35: ("Представлен вывод команды free.    $ free -m   total used free shared buff/cache available   Mem: 6930 3598 843 183 2489 2919   Swap: 15999 4 15995   Поему доступной (available) памяти сейчас 2919, если свободной (free) памяти 843?", "Доступная память (available) включает свободную оперативную память (free) и часть памяти, используемую под буферы и кэш. Таким образом, она учитывает не только непосредственно свободную память, но и резервы, которые могут быть освобождены из буферов и кэша, если это необходимо."),
    36: ("Порядок загрузки дистрибутива Linux.", "BIOS/UEFI - Инициализация аппаратного обеспечения, выбор устройства загрузки. MBR/UEFI Boot Loader - Загрузка Master Boot Record или UEFI Boot Loader. GRUB - Загрузка GRUB (Grand Unified Bootloader). Kernel (vmlinuz) - Загрузка ядра Linux. Initrd/Initramfs - Загрузка временной файловой системы для предварительной настройки. Init Process - Запуск процесса init (или systemd). User Space - Запуск пользовательских процессов, вход в систему."),
    37: ("Что такое GitFlow?", "GitFlow - это методология работы с системой контроля версий Git, предложенная Винсентом Дриессеном. Она включает в себя особую структуру ветвлений, такие как master, develop, feature, release и hotfix, для управления разработкой, релизами и исправлением ошибок в проекте. Это обеспечивает структурированный подход к управлению кодовой базой в командной разработке."),
    38: ("Чем merge отличается от rebase?", "Merge - Создает новый коммит слияния. Создает дополнительные коммиты слияния, что делает историю более наглядной. Безопасен для общих веток. Rebase -  Переписывает историю коммитов. Создает линейную историю без дополнительных коммитов слияния. Может вызвать проблемы при работе с общими ветками."),
    39: ("В ветке develop есть коммит с изменениями, которые нужно перенести в ветку master. Как это сделать?", "git checkout master и git merge develop - merge. git checkout master и git rebase develop - rebase"),
    40: ("Чем tag отличается от branch?", "Branch (Ветка) - подвижная ссылка на последний коммит в своей истории, используется для разработки и поддержки отдельных линий разработки, может быть легко обновлена новыми коммитами.Tag (Метка) - статичная ссылка на конкретный коммит,используется для явного помечения важных состояний, например, релизов,не изменяется после создания."),
    41: ("Для чего нужна команда git commit --amend?", "Команда git commit --amend используется для добавления изменений к последнему коммиту или изменения его сообщения."),
    42: ("Что такое Trunk-based development?", "Trunk-Based Development - методология разработки, где основная ветка (чаще всего master или main) считается стабильной. Разработчики интегрируют свой код напрямую в эту ветку, минимизируя использование долгоживущих веток разработки. Это способствует быстрой интеграции, частым релизам и высокой готовности кода к выпуску."),
    43: ("Состояние репозитория ушло на много коммитов вперед. Как откатить весь репозиторий к определенному коммиту?", "git reset --hard <SHA-коммита>  Где <SHA-коммита> - это хэш-идентификатор коммита. После этого, возможно, потребуется использовать git push --force при пуше в удаленный репозиторий.  "),
    44: ("В репозиторий запушен коммит с изменениями в двух файлах. Как откатить изменения этого коммита?", "git revert HEAD"),
    45: ("Что такое Docker? В чем отличие контейнера от образа?Что такое Docker? В чем отличие контейнера от образа?", "Docker - открытая платформа для автоматизации разработки, доставки и эксплуатации приложений в контейнерах.Контейнер в Docker: Изолированное выполнение процесса собственного приложения, разделяющее ядро операционной системы с другими контейнерами.Образ в Docker: Шаблон для создания контейнера, состоящий из файловой системы и метаданных, используемый для упаковки приложений и их зависимостей.Преимущества Docker: Портативность, изоляция, легковесность."),
    46: ("Какие инструкции есть у Dockerfile?", "FROM - Указывает базовый образ.RUN - Выполняет команды в контексте образа.COPY - Копирует файлы или директории.ADD - Копирует и распаковывает файлы, может загружать из URL.WORKDIR - Устанавливает рабочую директорию.CMD - Устанавливает команду по умолчанию.EXPOSE - Открывает порт.ENV - Устанавливает переменные среды.ENTRYPOINT - Указывает исполняемую команду.VOLUME - Создает точку монтирования для данных."),
    47: ("Чем отличается CMD от ENTRYPOINT в Dockerfile?", "CMD - определяет аргументы по умолчанию для команды запуска контейнера, может быть переопределено при запуске контейнера, может быть только одно в Dockerfile. ENTRYPOINT - определяет исполняемую команду для запуска контейнера, может быть переопределено при запуске контейнера, позволяет использовать контейнер как исполняемый файл,Может быть только одно в Dockerfile."),
    48: ("Чем отличается COPY от ADD в Dockerfile?", "COPY - простая инструкция для копирования файлов и директорий, работает только с локальными файлами и директориями. ADD - все функции COPY и дополнительно поддерживает скачивание файлов из URL и автоматическую распаковку тар-архивов"),
    49: ("Какие есть best practices для написания Dockerfile?", "Официальные базовые образы - Используйте официальные образы. Оптимизация слоев - Разбивайте команды на слои. Очищайте кеш - Убедитесь в очистке кеша после установки пакетов..dockerignore - Используйте .dockerignore.Уменьшайте привилегии - Используйте не-root пользователя.HEALTHCHECK -Добавьте HEALTHCHECK.Логирование и вывод -Настройте логирование.Ограничивайте ресурсы - Ограничивайте память и CPU.Уменьшайте размер образа - Минимизируйте размер образа..env файл для конфигурации -Используйте .env файл.Проверка безопасности - Используйте инструменты проверки безопасности.Регулярное обновление - Поддерживайте регулярные обновления Dockerfile."),
    50: ("Какие типы сетевых драйверов используются в docker?", "bridge - Стандартный драйвер, обеспечивает изоляцию контейнеров на одном хосте.host - Контейнеры используют сеть хоста, не изолированную друг от друга.none - Контейнер не имеет сетевого доступа.overlay - Объединяет контейнеры на разных хостах в виртуальную сеть.macvlan - Назначает уникальные MAC- и IP-адреса контейнерам в локальной сети.ipvlan - Эффективный вариант macvlan с уникальными IP-адресами для каждого контейнера."),
    51: ("Что такое эфемерные контейнеры?", "Эфемерные контейнеры - временные контейнеры в Kubernetes, запускаемые внутри существующего пода для выполнения задач, отладки или диагностики. Они предоставляют возможность взаимодействия с контейнерами в поде без изменения его состава."),
}

def start(update, context):
    user_id = update.effective_user.id
    context.bot.send_message(user_id, "Привет! Вот 50 вопросов для тебя. Выбери номер вопроса, чтобы получить на него ответ")
    for question_number, (question, _) in questions_and_answers.items():
        context.bot.send_message(user_id, f"{question_number}. {question}")

def answer(update, context):
    user_id = update.effective_user.id
    message_text = update.message.text

    try:
        question_number = int(message_text)
        _, answer_text = questions_and_answers.get(question_number, ("", "Увы, такого вопроса нет"))
        context.bot.send_message(user_id, answer_text)
    except ValueError:
        context.bot.send_message(user_id, "Пожалуйста, введите номер вопроса.")

def main():
    updater = Updater(TOKEN, use_context=True)
    dispatcher = updater.dispatcher

    # Обработчик команды start
    dispatcher.add_handler(CommandHandler("start", start))

    # Обработчик ответов на вопросы
    dispatcher.add_handler(MessageHandler(Filters.text & ~Filters.command, answer))

    # Запуск бота
    updater.start_polling()
    updater.idle()

if __name__ == '__main__':
    main()


#6930205247:AAGUvM-Xv5eN3AGld67LQ8CoeZvynWIPsbM
